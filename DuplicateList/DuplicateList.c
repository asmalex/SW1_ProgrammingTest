#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>
#include <assert.h>
#include <malloc.h>

// Linked List Node
typedef struct Node_s
{
    struct Node_s* next;        // points to next node in the list
    struct Node_s* reference;   // points to random node in the list
} Node_t;

// Generate a random linked list
static Node_t* GenerateList(uint32_t numNodes)
{
    Node_t* head = (Node_t*)malloc(sizeof(Node_t));
    assert(head != NULL);
    head->reference = NULL;
    head->next = NULL;

    Node_t* cursor = head;
    for (uint32_t i = 0; i < (numNodes - 1); ++i)
    {
        Node_t* node = (Node_t*)malloc(sizeof(Node_t));
        assert(node != NULL);

        node->next = NULL;
        node->reference = NULL;

        cursor->next = node;
        cursor = node;
    }

    cursor = head;
    while (cursor != NULL)
    {
        // find a random node in the list
        uint32_t r = (uint32_t)(rand() % numNodes);
        assert(r < numNodes);

        Node_t* ref = head;
        for (uint32_t i = 0; i < r; ++i)
        {
            ref = ref->next;
            assert(ref != NULL);
        }

        cursor->reference = ref;
        cursor = cursor->next;
    }

    return head;
}

// Print the list
static void PrintList(Node_t* list)
{
    uint32_t count = 0;
    while (list != NULL)
    {
        printf("Node %i: me(%p), next(%p), ref(%p)\n", count, list, list->next, list->reference);
        list = list->next;

        ++count;
    }
}

// TODO: implement this function
//ASSUMPTION: This is not a circular linked list. The last node must have a next pointer of null.
static Node_t* DuplicateList(Node_t* list)
{
    //sanity check we don't violate
    if (list == NULL)
        return NULL; 

    /*
    Node_t* prevReferenceNode   = NULL;
    Node_t* prevNode            = NULL;



    while (list->next != NULL)
    {
        //copy next item in list


    }
    //copy the last item in the list

    Node_t* new_list = (Node_t*)malloc(sizeof(Node_t));
    new_list->next = NULL;
    new_list->reference = prevReferenceNode; 
    return new_list;




    //base case
    //we are at the end of the list. Begin copying.
    if (list->next = NULL)
    {
        Node_t* new_list = (Node_t*)malloc(sizeof(Node_t));
        new_list->next = NULL;
        new_list->reference = list->reference; // NO NO NO
        return new_list;
    }

    //recursively copy the next item in the list
    Node_t* new_list = (Node_t*)malloc(sizeof(Node_t));
    new_list->next = DuplicateList(list->next);
    new_list->reference = NULL;
    return new_list;

    DuplicateList();
    */

    // placeholder
    Node_t* new_list = (Node_t*)malloc(sizeof(Node_t));
    new_list->next = NULL;
    new_list->reference = NULL;
    return new_list;
    
}

int main()
{
    /*
    Given a linked list using the following data structure:

    typedef struct Node_s
    {
        struct Node_s* next;
        struct Node_s* reference;
    } Node_t;

    Implement the function DuplicateList() which makes a copy of the linked list.  The input list is a singly linked list with nodes which reference random nodes within the list.
    The input list is generated by calling GenerateList()

    input: a singly linked list (each node contains a pointer to the next node in the list).  Additionaly, each node contains a second pointer that references a random node within the list.
                          /------->-------\
                          |               |
          /------->-------|               |
          |               |               |
         [a]==>==[b]==>==[c]==>==[d]==>==[e]
          |       |       |       |       |
          |---<---/       \---<---/       |
          |                               |
          \---------------<---------------/

    output: a duplicate copy of the list with no dependency on the original
                          /------->-------\
                          |               |
          /------->-------|               |
          |               |               |
         [L]==>==[M]==>==[N]==>==[O]==>==[P]
          |       |       |       |       |
          |---<---/       \---<---/       |
          |                               |
          \---------------<---------------/

    Note: when implementing please consider arbitrary input lists other than the one generated.
    A different random list can be set by changing the seed to srand() and changing number of nodes in the list.
    */
    srand(0);

    Node_t* list = GenerateList(5);
    Node_t* new_list = DuplicateList(list);

    printf("Original List:\n");
    PrintList(list);

    printf("\nNew List:\n");
    PrintList(new_list);

    printf("\nPress any key to continue...");

    char c;
    scanf("%c", &c);
}
